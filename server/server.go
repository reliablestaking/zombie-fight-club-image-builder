package server

import (
	"encoding/csv"
	"io"
	"net/http"
	"os"
	"strconv"
	"strings"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"github.com/sirupsen/logrus"

	echoSwagger "github.com/swaggo/echo-swagger"

	_ "github.com/reliablestaking/zc-image-builder/docs" // docs is generated by Swag CLI, you have to import it.
)

type (
	// Server struct
	Server struct {
		BuildTime        string
		Sha1ver          string
		ZombieChainMeta  map[string]ZombieChain
		ZombieHunterMeta map[string]ZombieHunter
		AlienRarity      AlienRarity
		ZfcBackgrounds   []string
	}

	// Version struct
	Version struct {
		Sha       string `json:"sha"`
		BuildTime string `json:"buildTime"`
	}
)

// Start the server
func (s Server) Start() {
	e := echo.New()

	//TODO: configurable?
	//e.Static("/static", "C:/Users/pike1/Documents/Cardano/NFTKeyMe/example-ui/")
	//e.Pre(s.CheckCookie)

	allowedOriginsCsv := make([]string, 0)
	allowedOrigins := os.Getenv("ALLOWED_ORIGINS")
	if allowedOrigins != "" {
		allowedOriginsCsv = strings.Split(allowedOrigins, ",")
	}

	e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
		AllowOrigins:     allowedOriginsCsv,
		AllowMethods:     []string{echo.GET, echo.HEAD, echo.PUT, echo.PATCH, echo.POST, echo.DELETE},
		AllowCredentials: true,
	}))

	e.Use(middleware.Logger())

	// builder endpoint
	e.GET("/images/zombiechain/:name", s.GetZombieChain)
	e.GET("/images/zombiehunter/:name", s.GetZombieHunter)

	e.GET("/images/alien/random", s.GetRandomAlien)
	e.POST("/images/alien", s.BuildAlien)

	e.POST("/images/zombiefight", s.BuildZombieFight)

	// version endpoint
	e.GET("/version", s.GetVersion)

	// swagger
	e.GET("/swagger/*", echoSwagger.WrapHandler)

	port := os.Getenv("NFTKEYME_SERVICE_PORT")
	if port == "" {
		port = "8080"
	}
	e.Logger.Fatal(e.Start(":" + port))
}

// GetVersion return build version info
func (s Server) GetVersion(c echo.Context) (err error) {
	version := Version{
		Sha:       s.Sha1ver,
		BuildTime: s.BuildTime,
	}

	return c.JSON(http.StatusOK, version)
}

func LoadMeta(path string) (map[string]ZombieChain, map[string]ZombieHunter, error) {
	// load zombie meta
	zombies, err := LoadZombieChainsMeta(path)
	if err != nil {
		logrus.WithError(err).Fatal("Error loading zc meta")
		return nil, nil, err
	}
	logrus.Infof("Loaded %d zombie chains meta entries", len(zombies))

	// load hunter meta
	hunters, err := LoadZombieHunterMeta(path)
	if err != nil {
		logrus.WithError(err).Fatal("Error loading zh meta")
		return nil, nil, err
	}
	logrus.Infof("Loaded %d zombie hunter meta entries", len(hunters))

	return zombies, hunters, nil
}

func LoadAlienRarity() (AlienRarity, error) {
	ar := AlienRarity{
		Backgrounds: make([]string, 0),
		Skins:       make([]string, 0),
		Hats:        make([]string, 0),
		Hands:       make([]string, 0),
		Eyes:        make([]string, 0),
		Mouths:      make([]string, 0),
		Clothes:     make([]string, 0),
	}

	// open file
	f, err := os.Open("images/alien/alien_trait_rarity.csv")
	if err != nil {
		return ar, err
	}
	defer f.Close()

	// Parse the file
	r := csv.NewReader(f)

	// skip first row
	_, err = r.Read()
	if err == io.EOF {
		return ar, err
	}
	// Iterate through the records
	for {
		// Read each record from csv
		record, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			logrus.WithError(err).Fatal("Error reading row")
		}

		traitType := record[0]
		traitName := record[1]
		traitRarity := record[2]
		traitRarityInt, err := strconv.Atoi(traitRarity)
		if err != nil {
			logrus.WithError(err).Fatal("Error parsing rarity %s", traitRarity)
		}

		if traitType == "background" {
			ar.Backgrounds = append(ar.Backgrounds, buildSlice(traitName, traitRarityInt)...)
		} else if traitType == "clothes" {
			ar.Clothes = append(ar.Clothes, buildSlice(traitName, traitRarityInt)...)
		} else if traitType == "eyes" {
			ar.Eyes = append(ar.Eyes, buildSlice(traitName, traitRarityInt)...)
		} else if traitType == "hand" {
			ar.Hands = append(ar.Hands, buildSlice(traitName, traitRarityInt)...)
		} else if traitType == "hat" {
			ar.Hats = append(ar.Hats, buildSlice(traitName, traitRarityInt)...)
		} else if traitType == "mouth" {
			ar.Mouths = append(ar.Mouths, buildSlice(traitName, traitRarityInt)...)
		} else if traitType == "skin" {
			ar.Skins = append(ar.Skins, buildSlice(traitName, traitRarityInt)...)
		}

	}

	return ar, nil
}

func LoadBackgroundRarity() ([]string, error) {
	backgrounds := make([]string, 0)

	// open file
	f, err := os.Open("metadata/zfc-backgrounds.csv")
	if err != nil {
		return backgrounds, err
	}
	defer f.Close()

	// Parse the file
	r := csv.NewReader(f)

	// Iterate through the records
	for {
		// Read each record from csv
		record, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			logrus.WithError(err).Fatal("Error reading row")
		}

		traitName := record[0]
		traitRarity := record[1]
		traitRarityInt, err := strconv.Atoi(traitRarity)
		if err != nil {
			logrus.WithError(err).Fatalf("Error parsing rarity %s", traitRarity)
		}

		backgrounds = append(backgrounds, buildSlice(traitName, traitRarityInt)...)

	}

	return backgrounds, nil
}

func buildSlice(name string, entries int) []string {
	names := make([]string, 0)

	for i := 1; i < entries; i++ {
		names = append(names, name)
	}

	return names
}
